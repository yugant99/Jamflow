#!/usr/bin/env python3
"""
Test the specific piano code generated by our RAG system
"""

# The code that was generated:
piano_code = '''
// Set the tempo for the composition to a moderate and reflective pace (90 BPM).
setcpm(90);

// This composition creates a piano piece in C major, structured into three distinct layers:
// a foundational bass line, a rich chord progression, and a lyrical melody.
// All layers utilize the 'gm_acoustic_grand_piano' for a realistic and expressive sound.
stack(
  // Layer 1: Bass Line
  // Plays the root notes of the C major (I), A minor (vi), F major (IV), and G major (V) chords.
  // Each note is sustained for the full duration of its corresponding chord (4 beats using @4).
  // The gain is set lower to provide a solid, yet subtle, foundation, and some room reverb
  // is added for a sense of space and depth.
  note("<c2@4 a2@4 f2@4 g2@4>")
    .sound("gm_acoustic_grand_piano")
    .gain(0.6) // Slightly lower volume for the bass
    .room(0.3), // Moderate reverb for a spacious feel

  // Layer 2: Chord Progression
  // Provides the harmonic support with full voicings for C major, A minor, F major, and G major chords.
  // Each chord is also sustained for 4 beats (@4), perfectly aligning with the bass line.
  // The gain is balanced to ensure the chords are present and rich, complementing the bass
  // and providing a bed for the melody. Room reverb is consistent with the bass for cohesion.
  note("<[c3,e3,g3]@4 [a2,c3,e3]@4 [f2,a2,c3]@4 [g2,b2,d3]@4>")
    .sound("gm_acoustic_grand_piano")
    .gain(0.7) // Balanced volume for chords
    .room(0.3), // Moderate reverb

  // Layer 3: Melody Line
  // A dynamic and flowing melody designed to weave above the chords.
  // Each sequence of 8 notes corresponds to the 4-beat duration of each chord,
  // effectively creating an eighth-note rhythm (two notes per beat), which adds movement.
  // The melody is given a higher gain to ensure it stands out as the primary voice,
  // with slightly less reverb to maintain clarity and presence.
  note("<e4 d4 c4 g3 e4 d4 c4 g3> <c4 b3 a3 e3 c4 b3 a3 e3>")
    .sound("gm_acoustic_grand_piano")
    .gain(0.8) // Higher volume for melody prominence
    .room(0.2) // Less reverb for clarity
);
'''

print("üéπ PIANO CODE ANALYSIS")
print("=" * 50)
print("Generated code:")
print(piano_code)
print("\n" + "=" * 50)

# Check for potential issues
issues = []

if "gm_acoustic_grand_piano" in piano_code:
    print("‚úÖ Uses GM instrument: gm_acoustic_grand_piano")
else:
    issues.append("‚ùå No GM instrument found")

if "setcpm(" in piano_code:
    print("‚úÖ Sets tempo with setcpm()")
else:
    issues.append("‚ùå No tempo setting")

if "note(" in piano_code:
    print("‚úÖ Uses note() function")
else:
    issues.append("‚ùå No note() function")

if ".sound(" in piano_code:
    print("‚úÖ Uses .sound() method")
else:
    issues.append("‚ùå No .sound() method")

# Check for syntax issues
if piano_code.count('note("<e4 d4 c4 g3 e4 d4 c4 g3> <c4 b3 a3 e3 c4 b3 a3 e3>")') > 0:
    issues.append("‚ö†Ô∏è  ISSUE FOUND: Melody line is incomplete - missing closing parenthesis and method chain")

print(f"\nüîç POTENTIAL ISSUES:")
for issue in issues:
    print(f"  {issue}")

if not issues:
    print("  ‚úÖ No obvious syntax issues found")

print(f"\nüí° RECOMMENDATION:")
print("The code looks mostly correct but may have been truncated. Let me check the knowledge base for proper piano syntax...")
